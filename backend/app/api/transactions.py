from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List
import logging

from ..dependencies import get_db
from ..schemas.schemas import TransactionSchema, TransactionResponse, TransactionLineResponse
from ..services.ledger import (
    get_all_transactions,
    create_transaction,
    get_transaction_by_id,
    validate_transaction_data,
    validate_transaction_integrity,
    validate_all_transactions_integrity,
    get_accounting_equation_status,
)
from ..auth.dependencies import require_permission
from ..auth.schemas import CurrentUser

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/transactions",
    tags=["transactions"],
)


@router.get("", response_model=List[TransactionResponse],
           summary="[DATABASE] List All Transactions",
           description="""
           Retrieve all financial transactions with their journal entries.
           
           **Permission Required:** `transaction:read`
           
           Returns complete transaction history including:
           - Transaction details (date, description, reference)
           - Journal entry lines (debits and credits)
           - Account allocations and amounts
           - Transaction sources (manual, import, system)
           """)
async def list_transactions(
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = Depends(require_permission("transaction:read"))
):
    """Get all transactions."""
    logger.info(f"[DATABASE] Retrieving all transactions for user: {current_user.username}")
    try:
        transactions = await get_all_transactions(db)
        logger.info(f"[SUCCESS] Retrieved {len(transactions)} transactions from database")
        
        # Transform to response format
        result = []
        for tx in transactions:
            logger.debug(f"[PROCESSING] Processing transaction ID={tx.id}, Lines={len(tx.lines)}")
            lines = [
                TransactionLineResponse(
                    account_name=line.account.name,
                    account_type=line.account.type.value,
                    type=line.type,
                    amount=line.amount
                )
                for line in tx.lines
            ]
            result.append(TransactionResponse(
                id=tx.id,
                date=tx.date,
                description=tx.description,
                source=tx.source.value,
                reference=tx.reference,
                created_at=tx.created_at,
                created_by=tx.created_by,
                lines=lines
            ))
        
        logger.info(f"[SUCCESS] Successfully transformed and returning {len(result)} transactions")
        return result
    except Exception as e:
        logger.error(f"[ERROR] Error retrieving transactions: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to retrieve transactions")


@router.post("", response_model=TransactionSchema,
            summary="üí∞ Create New Transaction",
            description="""
            Record a new financial transaction with journal entries.
            
            **Permission Required:** `transaction:create`
            
            **Double-Entry Bookkeeping Rules:**
            - Total debits must equal total credits
            - Each transaction must have at least 2 journal lines
            - Account names must exist in the chart of accounts
            
            **Transaction Sources:**
            - `manual` - Manually entered transactions
            - `import` - Imported from external systems
            - `system` - Auto-generated by system processes
            """)
async def add_transaction(
    transaction: TransactionSchema, 
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = Depends(require_permission("transaction:create"))
):
    """Create a new transaction."""
    logger.info(f"[TRANSACTION] Creating new transaction: '{transaction.description}' with {len(transaction.lines)} lines by user: {current_user.username}")
    
    # Log transaction details
    total_debit = sum(line.amount for line in transaction.lines if line.type == 'debit')
    total_credit = sum(line.amount for line in transaction.lines if line.type == 'credit')
    logger.info(f"[DATABASE] Transaction balance check: Debit={total_debit}, Credit={total_credit}")
    
    for i, line in enumerate(transaction.lines, 1):
        logger.debug(f"[DETAILS] Line {i}: Account='{line.account_name}', Type={line.type}, Amount={line.amount}")
    
    try:
        new_transaction = await create_transaction(db, transaction)
        logger.info(f"[SUCCESS] Successfully created transaction: ID={new_transaction.id}")
        return new_transaction
    except ValueError as e:
        logger.warning(f"[WARNING] Business validation error creating transaction: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"[ERROR] Unexpected error creating transaction: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to create transaction")


@router.get("/{transaction_id}", response_model=TransactionSchema)
async def get_transaction(
    transaction_id: int, 
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = Depends(require_permission("transaction:read"))
):
    """Get a specific transaction by ID."""
    logger.info(f"[SEARCH] Retrieving transaction with ID={transaction_id} for user: {current_user.username}")
    try:
        transaction = await get_transaction_by_id(db, transaction_id)
        if transaction:
            logger.info(f"[SUCCESS] Successfully retrieved transaction: ID={transaction.id}, Description='{transaction.description}'")
            return transaction
        else:
            logger.warning(f"[WARNING] Transaction not found: ID={transaction_id}")
            raise HTTPException(status_code=404, detail="Transaction not found")
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[ERROR] Error retrieving transaction ID={transaction_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to retrieve transaction")


# ============================================================================
# DOUBLE-ENTRY VALIDATION ENDPOINTS
# ============================================================================

@router.post("/validate", 
            summary="üîç Validate Transaction Data",
            description="""
            Comprehensive validation for transaction data before creation.
            
            **Permission Required:** `transaction:create`
            
            Performs enterprise-grade double-entry bookkeeping validation:
            - ‚úÖ Balance verification (Debits = Credits)
            - ‚úÖ Account existence and status checks
            - ‚úÖ Amount precision and formatting
            - ‚úÖ Accounting equation impact analysis
            - ‚úÖ Business logic validation
            
            Returns detailed validation results with errors and warnings.
            """)
async def validate_transaction(
    transaction: TransactionSchema,
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = Depends(require_permission("transaction:create"))
):
    """Validate transaction data without creating it."""
    logger.info(f"[VALIDATION] Validating transaction: '{transaction.description}' for user: {current_user.username}")
    
    try:
        validation_result = await validate_transaction_data(db, transaction)
        
        return {
            "is_valid": validation_result.is_valid,
            "errors": validation_result.errors,
            "warnings": validation_result.warnings,
            "transaction_description": transaction.description,
            "total_lines": len(transaction.lines),
            "total_debits": sum(line.amount for line in transaction.lines if line.type == 'debit'),
            "total_credits": sum(line.amount for line in transaction.lines if line.type == 'credit'),
        }
    except Exception as e:
        logger.error(f"[ERROR] Error validating transaction: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to validate transaction")


@router.get("/{transaction_id}/validate",
           summary="üîç Validate Existing Transaction",
           description="""
           Post-commit validation for existing transaction integrity.
           
           **Permission Required:** `transaction:read`
           
           Checks database integrity for a specific transaction:
           - ‚úÖ Balance verification at database level
           - ‚úÖ Account reference integrity
           - ‚úÖ Data consistency checks
           """)
async def validate_existing_transaction(
    transaction_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = Depends(require_permission("transaction:read"))
):
    """Validate integrity of an existing transaction."""
    logger.info(f"[VALIDATION] Validating existing transaction ID={transaction_id} for user: {current_user.username}")
    
    try:
        validation_result = await validate_transaction_integrity(db, transaction_id)
        
        return {
            "transaction_id": transaction_id,
            "is_valid": validation_result.is_valid,
            "errors": validation_result.errors,
            "warnings": validation_result.warnings,
        }
    except Exception as e:
        logger.error(f"[ERROR] Error validating transaction ID={transaction_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to validate transaction")


@router.get("/system/validate-all",
           summary="üîç System-Wide Validation",
           description="""
           Comprehensive system-wide transaction integrity validation.
           
           **Permission Required:** `system:audit`
           
           Performs complete audit of all transactions:
           - ‚úÖ Validates every transaction in the system
           - ‚úÖ Identifies data integrity issues
           - ‚úÖ Provides comprehensive audit report
           
           **Warning:** This is a resource-intensive operation.
           """)
async def validate_all_transactions(
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = Depends(require_permission("system:audit"))
):
    """Validate integrity of all transactions in the system."""
    logger.info(f"[VALIDATION] Starting system-wide validation for user: {current_user.username}")
    
    try:
        validation_result = await validate_all_transactions_integrity(db)
        
        return {
            "is_valid": validation_result.is_valid,
            "errors": validation_result.errors,
            "warnings": validation_result.warnings,
            "total_errors": len(validation_result.errors),
            "total_warnings": len(validation_result.warnings),
        }
    except Exception as e:
        logger.error(f"[ERROR] Error during system-wide validation: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to perform system-wide validation")


@router.get("/system/accounting-equation",
           summary="üìä Accounting Equation Status",
           description="""
           Get current accounting equation status and balance.
           
           **Permission Required:** `financial:read`
           
           Returns fundamental accounting equation analysis:
           - üìà Assets = Liabilities + Equity
           - üí∞ Account type totals and balances
           - üèÜ Retained earnings calculation
           - ‚úÖ Equation balance verification
           """)
async def get_accounting_equation(
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = Depends(require_permission("financial:read"))
):
    """Get current accounting equation status."""
    logger.info(f"[ACCOUNTING] Retrieving accounting equation status for user: {current_user.username}")
    
    try:
        equation_status = await get_accounting_equation_status(db)
        
        # Convert Decimal to float for JSON serialization
        return {
            "assets": float(equation_status["assets"]),
            "liabilities": float(equation_status["liabilities"]),
            "equity": float(equation_status["equity"]),
            "income": float(equation_status["income"]),
            "expenses": float(equation_status["expenses"]),
            "retained_earnings": float(equation_status["retained_earnings"]),
            "total_equity": float(equation_status["total_equity"]),
            "equation_balance": float(equation_status["equation_balance"]),
            "equation_balanced": equation_status["equation_balanced"],
            "equation_formula": "Assets = Liabilities + Equity",
            "validation_threshold": 0.01,
        }
    except Exception as e:
        logger.error(f"[ERROR] Error retrieving accounting equation: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to retrieve accounting equation status")