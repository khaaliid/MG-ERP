from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List
import logging

from ..dependencies import get_db
from ..schemas.schemas import TransactionSchema, TransactionResponse, TransactionLineResponse
from ..services.ledger import (
    get_all_transactions,
    create_transaction,
    get_transaction_by_id,
)
from ..auth.dependencies import require_permission
from ..auth.schemas import CurrentUser

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/transactions",
    tags=["transactions"],
)


@router.get("/", response_model=List[TransactionResponse],
           summary="ðŸ“Š List All Transactions",
           description="""
           Retrieve all financial transactions with their journal entries.
           
           **Permission Required:** `transaction:read`
           
           Returns complete transaction history including:
           - Transaction details (date, description, reference)
           - Journal entry lines (debits and credits)
           - Account allocations and amounts
           - Transaction sources (manual, import, system)
           """)
async def list_transactions(
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = Depends(require_permission("transaction:read"))
):
    """Get all transactions."""
    logger.info(f"[DATABASE] Retrieving all transactions for user: {current_user.username}")
    try:
        transactions = await get_all_transactions(db)
        logger.info(f"[SUCCESS] Retrieved {len(transactions)} transactions from database")
        
        # Transform to response format
        result = []
        for tx in transactions:
            logger.debug(f"[PROCESSING] Processing transaction ID={tx.id}, Lines={len(tx.lines)}")
            lines = [
                TransactionLineResponse(
                    account_name=line.account.name,
                    account_type=line.account.type.value,
                    type=line.type,
                    amount=line.amount
                )
                for line in tx.lines
            ]
            result.append(TransactionResponse(
                id=tx.id,
                date=tx.date,
                description=tx.description,
                source=tx.source.value,
                reference=tx.reference,
                created_at=tx.created_at,
                created_by=tx.created_by,
                lines=lines
            ))
        
        logger.info(f"[SUCCESS] Successfully transformed and returning {len(result)} transactions")
        return result
    except Exception as e:
        logger.error(f"[ERROR] Error retrieving transactions: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to retrieve transactions")


@router.post("/", response_model=TransactionSchema,
            summary="ðŸ’° Create New Transaction",
            description="""
            Record a new financial transaction with journal entries.
            
            **Permission Required:** `transaction:create`
            
            **Double-Entry Bookkeeping Rules:**
            - Total debits must equal total credits
            - Each transaction must have at least 2 journal lines
            - Account names must exist in the chart of accounts
            
            **Transaction Sources:**
            - `manual` - Manually entered transactions
            - `import` - Imported from external systems
            - `system` - Auto-generated by system processes
            """)
async def add_transaction(
    transaction: TransactionSchema, 
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = Depends(require_permission("transaction:create"))
):
    """Create a new transaction."""
    logger.info(f"[TRANSACTION] Creating new transaction: '{transaction.description}' with {len(transaction.lines)} lines by user: {current_user.username}")
    
    # Log transaction details
    total_debit = sum(line.amount for line in transaction.lines if line.type == 'debit')
    total_credit = sum(line.amount for line in transaction.lines if line.type == 'credit')
    logger.info(f"[DATABASE] Transaction balance check: Debit={total_debit}, Credit={total_credit}")
    
    for i, line in enumerate(transaction.lines, 1):
        logger.debug(f"[DETAILS] Line {i}: Account='{line.account_name}', Type={line.type}, Amount={line.amount}")
    
    try:
        new_transaction = await create_transaction(db, transaction)
        logger.info(f"[SUCCESS] Successfully created transaction: ID={new_transaction.id}")
        return new_transaction
    except ValueError as e:
        logger.warning(f"[WARNING] Business validation error creating transaction: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"[ERROR] Unexpected error creating transaction: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to create transaction")


@router.get("/{transaction_id}", response_model=TransactionSchema)
async def get_transaction(
    transaction_id: int, 
    db: AsyncSession = Depends(get_db),
    current_user: CurrentUser = Depends(require_permission("transaction:read"))
):
    """Get a specific transaction by ID."""
    logger.info(f"[SEARCH] Retrieving transaction with ID={transaction_id} for user: {current_user.username}")
    try:
        transaction = await get_transaction_by_id(db, transaction_id)
        if transaction:
            logger.info(f"[SUCCESS] Successfully retrieved transaction: ID={transaction.id}, Description='{transaction.description}'")
            return transaction
        else:
            logger.warning(f"[WARNING] Transaction not found: ID={transaction_id}")
            raise HTTPException(status_code=404, detail="Transaction not found")
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[ERROR] Error retrieving transaction ID={transaction_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to retrieve transaction")